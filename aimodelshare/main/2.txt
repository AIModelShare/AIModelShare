import boto3
import cv2
import os
import numpy as np
import json
import onnxruntime as rt
import base64
import imghdr
import six
from functools import partial
import os.path
from os import path

def get_model_onnx(runtimemodel_s3_filename="runtime_model.onnx"):
  s3 = boto3.resource("s3")
  bucket = s3.Bucket("{0}")

  with open("/tmp/runtime_model.onnx", "wb") as modelfo:
      bucket.download_fileobj("{1}/runtime_model.onnx",  modelfo)
      model = rt.InferenceSession("/tmp/runtime_model.onnx")
  return model


def get_preprocessor(preprocessor_s3_filename="runtime_preprocessor.pkl"):
      s3 = boto3.resource("s3")
      bucket = s3.Bucket("{0}")

      with open("/tmp/runtime_preprocessor.pkl", "wb") as preprocessorfo:
          bucket.download_fileobj("{1}/runtime_preprocessor.pkl",  preprocessorfo)
          preprocessorfo.seek(0)
          preprocessor = pickle.load(open("/tmp/runtime_preprocessor.pkl","rb"))
      return preprocessor

def get_runtimedata(runtimedata_s3_filename="runtime_data.json"):

      s3 = boto3.resource('s3')
      obj = s3.Object("{0}", "{1}"+"/"+runtimedata_s3_filename)
      runtime_data = json.load(obj.get()['Body'])

      return runtime_data


runtime_data=get_runtimedata(runtimedata_s3_filename="runtime_data.json")

preprocessor_type=runtime_data["runtime_preprocessor"]

runtime_model=runtime_data["runtime_model"]["name"]

model=get_model_onnx(runtimemodel_s3_filename='runtime_model.onnx')

# Load preprocessor

try:
  assert preprocessor_type=="module"
except:
  preprocessor=get_preprocessor(preprocessor_s3_filename="runtime_preprocessor.pkl")
else:
  import preprocessor

def predict(event,model,preprocessor,preprocessor_type):

# Load base64 encoded image stored within "data" key of event dictionary
  print(event["body"])
  body = event["body"]
  if isinstance(event["body"], six.string_types):
        body = json.loads(event["body"])
        
  bodydata=body["data"]

# Extract image file extension (e.g.-jpg, png, etc.)
  sample = base64.decodebytes(bytearray(bodydata, "utf-8"))

  for tf in imghdr.tests:
    image_file_type = tf(sample, None)
    if image_file_type:
      break;
  image_file_type=image_file_type
 
  if(image_file_type==None):
    print("This file is not an image, please submit an image base64 encoded image file.")

# Save image to local file, read into session, and preprocess image with preprocessor function

  with open("/tmp/imagetopredict."+image_file_type, "wb") as fh:
    fh.write(base64.b64decode(bodydata))

  img = cv2.imread("/tmp/imagetopredict."+image_file_type)
  
  import preprocessor as prep
  input_data = prep.preprocessor(img)

# Generate prediction using preprocessed input data
  print("The model expects input shape:", model.get_inputs()[0].shape)
  
  input_name = model.get_inputs()[0].name

  res = model.run(None, {{input_name: input_data}})
 
  #extract predicted probability for all classes, extract predicted label
  
  prob = res[0]

  def predict_classes(x): 
    proba=x
    if proba.shape[-1] > 1:
      return proba.argmax(axis=-1)
    else:
      return (proba > 0.5).astype("int32")
      
  prediction_index=predict_classes(prob)

  labels={2}
  result=list(map(lambda x: labels[x], prediction_index))

  os.remove("/tmp/imagetopredict."+image_file_type)

  return result

def handler(event, context):

    result = predict(event,model,preprocessor,preprocessor_type)
    return {{"statusCode": 200,
    "headers": {{
    "Access-Control-Allow-Origin" : "*",
    "Access-Control-Allow-Credentials": True,
    "Allow" : "GET, OPTIONS, POST",
    "Access-Control-Allow-Methods" : "GET, OPTIONS, POST",
    "Access-Control-Allow-Headers" : "*"
    }},
    "body" : json.dumps(result)}}